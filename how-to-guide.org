#+TITLE: How-to Software Guide (CWI CI Group)
#+AUTHOR: Jan-Willem Buurlage, Allard Hendriksen
#+LANGUAGE: en
#+OPTIONS: toc:nil h:4 html-postamble:nil html-preamble:t tex:t f:t
#+OPTIONS: prop:("VERSION")
#+HTML_DOCTYPE: <!DOCTYPE html>
#+HTML_HEAD: <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
#+HTML_HEAD: <link href="css/style.css" rel="stylesheet" type="text/css" />
#+LaTeX_CLASS: book

* TODO Introduction
* How-to
** Python
*** TODO Auto-format your code
**** PEP8
**** [[https://github.com/google/yapf][yapf]]
** C++
*** TODO Auto-format your code
**** =clang-format=
*** TODO Use CMake to build your software
**** C++ Weekly, [[https://www.youtube.com/watch?v=HPMvU64RUTY][Intro to CMake]]
**** [[https://llvm.org/docs/CMakePrimer.html][CMakePrimer (LLVM)]]
**** [[https://www.youtube.com/watch?v=eC9-iRN2b04][CppCon 2017: Mathieu Ropert “Using Modern CMake Patterns to Enforce a Good Modular Design”]]
**** [[https://www.youtube.com/watch?v=bsXLMQ6WgIk][C++Now 2017: Daniel Pfeifer “Effective CMake"]]
**** [[https://foonathan.net/blog/2016/07/07/cmake-dependency-handling.html][Dependency management CMake/Git]]
Example:
#+BEGIN_SRC cmake
find_package(ZeroMQ QUIET)

if (ZeroMQ_FOUND)
    add_library(zmq INTERFACE)
    target_include_directories(zmq INTERFACE ${ZeroMQ_INCLUDE_DIR})
    target_link_libraries(zmq INTERFACE ${ZeroMQ_LIBRARY})
else()
    message("'zmq' not installed on the system, building from source...")

    execute_process(COMMAND git submodule update --init --remote -- ext/libzmq
        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})

    set(ZMQ_BUILD_TESTS OFF CACHE BOOL "disable tests" FORCE)
    set(WITH_PERF_TOOL OFF CACHE BOOL "disable perf-tools" FORCE)
    add_subdirectory(${CMAKE_SOURCE_DIR}/ext/libzmq)
    set(ZMQ_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/ext/libzmq/include)

    # ZeroMQ names their target libzmq, which is inconsistent => create a ghost dependency
    add_library(zmq INTERFACE)
    target_link_libraries(zmq INTERFACE libzmq)
endif()
#+END_SRC
**** https://foonathan.net/blog/2018/10/17/cmake-warnings.html
*** TODO Use a good set of compile commands
**** Sensible compile flags
***** =-Wall=
***** =-Werror=
***** =-Wfatal=
***** ...
*** TODO Manage dynamic dependencies
Three places that a binary looks for shared dependencies
1. =LD_LIBRARY_PATH=
2. =rpath= encoded in binary
3. system default paths

Danger of (1) is that it overrides the specific dependencies of all binaries run.

For shared systems, or non-root users, (3) can be a problem.

For 2 you proceed as follows:
- set =LD_RUN_PATH= to something hardcoded
- use =-R= in gcc

To check the =RPATH= in a binary on Linux, use =readelf -d <binary>=.

To list all dynamic dependencies, use =ldd <binary>=

See also: [[https://www.eyrie.org/~eagle/notes/rpath.html]].
*** Create Python bindings using =pybind11=
Adding Python bindings to C++ code is straightforward with pybind11. A good
setup is as follows. (All relative to the root folder of the C++ project, which
I call =your_project= here)
**** Add pybind11 as a git submodule
#+BEGIN_SRC bash
git submodule add https://github.com/pybind/pybind11.git ext/pybind11
#+END_SRC
**** Set up the Python bindings
Make a directory =python=, containing at least three files:
***** =python/src/module.cpp=
This contains the actual bindings, an example is like this:
#+BEGIN_SRC cpp
#include <pybind11/pybind11.h>
namespace py = pybind11;

#include "your_project/your_project.hpp"

using namespace your_project;

PYBIND11_MODULE(py_your_project, m) {
    m.doc() = "bindings for your_project";

    py::class_<your_project::object>(m, "object");
}
#+END_SRC
***** =python/your_project/__init__.py=
The entry point for the Python specific code of your project. Also reexports
symbols from the generated bindings.
#+BEGIN_SRC python
from py_your_project import *
#+END_SRC
***** =python/CMakeLists.txt=
You can build the bindings using CMake.
#+BEGIN_SRC cmake
set(BINDING_NAME "py_your_project")
set(BINDING_SOURCES "src/module.cpp")

set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")

pybind11_add_module(${BINDING_NAME} ${BINDING_SOURCES})

target_link_libraries(${BINDING_NAME} PRIVATE your_project)
#+END_SRC
**** Add it as a subdirectory
In the main =CMakeLists.txt= of your project, add the Python folder:
#+BEGIN_SRC cmake
...
add_subdirectory("ext/pybind11")
add_subdirectory("python")
#+END_SRC
Now, the python bindings will be built alongside your project.
** General
*** TODO Write good documentation
- http://stevelosh.com/blog/2013/09/teach-dont-tell/
*** TODO Write good commit messages
- http://chris.beams.io/posts/git-commit/
*** TODO Write a good readme
[[https://github.com/LappleApple/feedmereadmes/blob/master/README-maturity-model.md][This github repo]] contains a useful model of maturity levels for a
project's README.md file. It defines both the current level of
maturity of a README and gives pointers on how to improve.
*** TODO Set up your Git branches
- *Branching model*: http://nvie.com/posts/a-successful-git-branching-model/
*** TODO Use module systems
*** TODO Set up travis CI
**** C++17
**** travis.yml / Makefile
